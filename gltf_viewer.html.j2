<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>

<style>
  #viewer { width: 100%; height: {{ height }}; position: relative; }
  #controls {
    position: absolute;
    top: 10px;
    right: 10px;
    background: rgba(255,255,255,0.9);
    padding: 10px;
    border-radius: 4px;
    font-family: sans-serif;
    font-size: 12px;
    z-index: 100;
  }
  #controls label { display: block; margin: 4px 0; cursor: pointer; }
  #controls input { margin-right: 6px; }
  #info-panel {
    display: none;
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: rgba(255,255,255,0.95);
    padding: 10px 14px;
    border-radius: 4px;
    font-family: sans-serif;
    font-size: 12px;
    z-index: 100;
    max-width: 300px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }
  #info-panel h4 { margin: 0 0 8px 0; font-size: 13px; }
  #info-panel .info-row { margin: 4px 0; }
  #info-panel .info-label { color: #666; }
</style>

<div id="viewer">
  <div id="controls">
    <strong>Surface Filters</strong>
    <label><input type="checkbox" id="showFloors" checked> Floors</label>
    <label><input type="checkbox" id="showWalls" checked> Walls</label>
    <label><input type="checkbox" id="showRoofs" checked> Roofs/Ceilings</label>
    <label><input type="checkbox" id="showWindows" checked> Windows</label>
    <label><input type="checkbox" id="showDoors" checked> Doors</label>
    <label><input type="checkbox" id="showShading" checked> Shading</label>
    <label><input type="checkbox" id="showPartitions" checked> Partitions</label>
    <hr style="margin: 8px 0; border: none; border-top: 1px solid #ccc;">
    <label><input type="checkbox" id="showEdges" checked> Show Edges</label>
  </div>
  <div id="info-panel">
    <h4 id="info-name"></h4>
    <div class="info-row"><span class="info-label">Type:</span> <span id="info-type"></span></div>
    <div class="info-row" id="info-space-row"><span class="info-label">Space:</span> <span id="info-space"></span></div>
    <div class="info-row" id="info-construction-row"><span class="info-label">Construction:</span> <span id="info-construction"></span></div>
    <div class="info-row" id="info-boundary-row"><span class="info-label">Boundary:</span> <span id="info-boundary"></span></div>
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

const container = document.getElementById("viewer");

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf5f5f5);

const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 5000);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(container.clientWidth, container.clientHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
container.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);

window.addEventListener('resize', () => {
  camera.aspect = container.clientWidth / container.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(container.clientWidth, container.clientHeight);
});

scene.add(new THREE.AmbientLight(0x888888));
scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 0.6));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(1, 2, 1);
scene.add(dirLight);

// Collect all meshes for filtering and selection
const sceneObjects = [];
// Map mesh -> edge lines
const objectEdges = new Map();
// Map mesh -> back face object
const backObjects = new Map();

// Selection state
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let selectedObject = null;
let originalMaterial = null;

const selectedMaterial = new THREE.MeshStandardMaterial({
  color: 0xffff00,
  emissive: 0x444400,
  side: THREE.DoubleSide
});

const infoPanel = document.getElementById('info-panel');

function selectObject(obj) {
  // Restore previous selection
  if (selectedObject && originalMaterial) {
    selectedObject.material = originalMaterial;
  }

  if (obj) {
    selectedObject = obj;
    originalMaterial = obj.material;
    obj.material = selectedMaterial;

    // Update info panel
    const data = obj.userData;
    document.getElementById('info-name').textContent = data.name || 'Unknown';
    document.getElementById('info-type').textContent = data.surfaceType || '';

    const spaceRow = document.getElementById('info-space-row');
    const space = document.getElementById('info-space');
    if (data.spaceName) {
      space.textContent = data.spaceName;
      spaceRow.style.display = 'block';
    } else {
      spaceRow.style.display = 'none';
    }

    const constructionRow = document.getElementById('info-construction-row');
    const construction = document.getElementById('info-construction');
    if (data.constructionName) {
      construction.textContent = data.constructionName;
      constructionRow.style.display = 'block';
    } else {
      constructionRow.style.display = 'none';
    }

    const boundaryRow = document.getElementById('info-boundary-row');
    const boundary = document.getElementById('info-boundary');
    if (data.outsideBoundaryCondition) {
      boundary.textContent = data.outsideBoundaryCondition;
      boundaryRow.style.display = 'block';
    } else {
      boundaryRow.style.display = 'none';
    }

    infoPanel.style.display = 'block';
  } else {
    selectedObject = null;
    originalMaterial = null;
    infoPanel.style.display = 'none';
  }
}

// Track mouse position for click vs drag detection
let mouseDownPos = { x: 0, y: 0 };

renderer.domElement.addEventListener('mousedown', (event) => {
  mouseDownPos.x = event.clientX;
  mouseDownPos.y = event.clientY;
});

renderer.domElement.addEventListener('click', (event) => {
  // Ignore if this was a drag (camera orbit)
  const dx = event.clientX - mouseDownPos.x;
  const dy = event.clientY - mouseDownPos.y;
  if (Math.abs(dx) > 5 || Math.abs(dy) > 5) return;

  const rect = renderer.domElement.getBoundingClientRect();
  mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

  raycaster.setFromCamera(mouse, camera);

  const visibleObjects = sceneObjects.filter(obj => obj.visible);
  const intersects = raycaster.intersectObjects(visibleObjects);

  if (intersects.length > 0) {
    selectObject(intersects[0].object);
  } else {
    selectObject(null);
  }
});

function updateVisibility() {
  const showFloors = document.getElementById('showFloors').checked;
  const showWalls = document.getElementById('showWalls').checked;
  const showRoofs = document.getElementById('showRoofs').checked;
  const showWindows = document.getElementById('showWindows').checked;
  const showDoors = document.getElementById('showDoors').checked;
  const showShading = document.getElementById('showShading').checked;
  const showPartitions = document.getElementById('showPartitions').checked;
  const showEdges = document.getElementById('showEdges').checked;

  sceneObjects.forEach(obj => {
    const surfaceType = obj.userData?.surfaceType || '';
    let visible = true;

    if (surfaceType === 'Floor') visible = showFloors;
    else if (surfaceType === 'Wall') visible = showWalls;
    else if (surfaceType === 'RoofCeiling') visible = showRoofs;
    else if (surfaceType.includes('Window') || surfaceType.includes('Skylight') || surfaceType.includes('TubularDaylight') || surfaceType === 'GlassDoor') visible = showWindows;
    else if (surfaceType.includes('Door')) visible = showDoors;
    else if (surfaceType.includes('Shading')) visible = showShading;
    else if (surfaceType === 'InteriorPartitionSurface') visible = showPartitions;

    obj.visible = visible;

    // Sync edge visibility
    const edges = objectEdges.get(obj);
    if (edges) {
      edges.visible = visible && showEdges;
    }

    // Sync back object visibility
    const backObj = backObjects.get(obj);
    if (backObj) {
      backObj.visible = visible;
    }
  });
}

// Add event listeners to checkboxes
['showFloors', 'showWalls', 'showRoofs', 'showWindows', 'showDoors', 'showShading', 'showPartitions', 'showEdges'].forEach(id => {
  document.getElementById(id).addEventListener('change', updateVisibility);
});

const gltfData = {{ gltf_data | tojson(indent=indent) }};

const loader = new GLTFLoader();
loader.parse(
  JSON.stringify(gltfData),
  "",
  (gltf) => {
    scene.add(gltf.scene);

    // Collect all meshes with userData for filtering
    const edgeMaterial = new THREE.LineBasicMaterial({ color: 0x000000 });
    gltf.scene.traverse(obj => {
      if (obj.isMesh && obj.userData?.surfaceType) {
        sceneObjects.push(obj);

        // Use OpenStudio's standard colors for surface types (exterior/front)
        const surfaceColors = {
          'Floor': 0x808080,
          'Wall': 0xccb266,
          'RoofCeiling': 0x994c4c,
          'Window': 0x66b2cc,
          'GlassDoor': 0x66b2cc,
          'Skylight': 0x66b2cc,
          'TubularDaylightDome': 0x66b2cc,
          'TubularDaylightDiffuser': 0x66b2cc,
          'Door': 0x99854c,
          'OverheadDoor': 0x99854c,
          'SiteShading': 0x4b7c95,
          'BuildingShading': 0x714c99,
          'SpaceShading': 0x4c6eb2,
          'InteriorPartitionSurface': 0x9ebc8f,
          'AirWall': 0x66b2cc,
        };
        // Interior/back colors (dimmer versions)
        const surfaceColorsInt = {
          'Floor': 0xbfbfbf,
          'Wall': 0xebe2c5,
          'RoofCeiling': 0xca9595,
          'Window': 0xc0e2eb,
          'GlassDoor': 0xc0e2eb,
          'Skylight': 0xc0e2eb,
          'TubularDaylightDome': 0xc0e2eb,
          'TubularDaylightDiffuser': 0xc0e2eb,
          'Door': 0xcabc95,
          'OverheadDoor': 0xcabc95,
          'SiteShading': 0xbbd1dc,
          'BuildingShading': 0xd8cbe5,
          'SpaceShading': 0xb7c5e0,
          'InteriorPartitionSurface': 0xd5e2cf,
          'AirWall': 0xc0e2eb,
        };
        const surfaceType = obj.userData?.surfaceType;
        const color = new THREE.Color(surfaceColors[surfaceType] ?? 0xcccccc);
        const colorInt = new THREE.Color(surfaceColorsInt[surfaceType] ?? 0xeeeeee);

        // Front face material
        obj.material = new THREE.MeshPhongMaterial({
          color: color,
          specular: 0x222222,
          shininess: 30,
          side: THREE.FrontSide
        });

        // Create back face object with interior color
        const backObj = obj.clone();
        backObj.material = new THREE.MeshPhongMaterial({
          color: colorInt,
          specular: 0x222222,
          shininess: 30,
          side: THREE.BackSide
        });
        obj.parent.add(backObj);
        backObjects.set(obj, backObj);

        // Create edge lines for this mesh
        const edgesGeometry = new THREE.EdgesGeometry(obj.geometry);
        const edges = new THREE.LineSegments(edgesGeometry, edgeMaterial);
        edges.position.copy(obj.position);
        edges.rotation.copy(obj.rotation);
        edges.scale.copy(obj.scale);
        obj.parent.add(edges);
        objectEdges.set(obj, edges);
      }
    });

    // Position camera using bounding box from GLTF metadata
    const bbox = gltfData.scenes?.[0]?.extras?.boundingbox;
    if (bbox) {
      // Convert from OpenStudio coords (Z-up) to Three.js coords (Y-up)
      const lookAt = new THREE.Vector3(bbox.lookAtX, bbox.lookAtZ, -bbox.lookAtY);
      const radius = 2.5 * bbox.lookAtR;

      // Position camera at an angle (similar to -30, 30 degrees)
      const theta = -30 * Math.PI / 180;
      const phi = 30 * Math.PI / 180;
      camera.position.set(
        radius * Math.cos(theta) * Math.cos(phi) + lookAt.x,
        radius * Math.sin(phi) + lookAt.y,
        -radius * Math.sin(theta) * Math.cos(phi) + lookAt.z
      );

      controls.target.copy(lookAt);
      controls.update();
    }

    animate();
  },
  (e) => console.error(e)
);

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
</script>
